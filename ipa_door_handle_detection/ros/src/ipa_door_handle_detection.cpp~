#include <ros/src/ipa_door_handle_detection.h>


PcImport::PcImport(ros::NodeHandle nh, sensor_msgs::PointCloud2::Ptr point_cloud_out_msg) :
		nh_(nh), point_cloud_out_msg_(point_cloud_out_msg)
{
	std::cout << "Initialising PcImport Constructor." << std::endl;

	pub_ = nh_.advertise<sensor_msgs::PointCloud2>("point_cloud_output",1);
	(pub_) ? std::cout << "Pub is valid." << std::endl : std::cout << "Pub is not valid." << std::endl;
	ros::Subscriber point_cloud_sub_ = nh_.subscribe<sensor_msgs::PointCloud2>("/camera/depth/points", 1, &PcImport::pointcloudCallback, this);
	ros::Duration(1).sleep();

	ros::Rate loop_rate(10);
	while (ros::ok())
	{
		ros::spinOnce();
		loop_rate.sleep();
	}

	std::cout << "PcImport Constructor Initialised." << std::endl;
}





void PcImport::pointcloudCallback(const sensor_msgs::PointCloud2::ConstPtr& point_cloud_msg)
{
	std::cout << "> Starting PC callback." << std::endl;

	//prepare out point cloud
//	const int element_size = point_cloud_msg->point_step;	// length of point in bytes
//	const int row_size = point_cloud_msg->row_step;			// length of row in bytes
//	point_cloud_out_msg_->fields = point_cloud_msg->fields;
//	point_cloud_out_msg_->header = point_cloud_msg->header;
//	point_cloud_out_msg_->height = point_cloud_msg->height;
//	point_cloud_out_msg_->width = point_cloud_msg->width;
//	point_cloud_out_msg_->point_step = point_cloud_msg->point_step;
//	point_cloud_out_msg_->row_step = point_cloud_msg->row_step;
//	point_cloud_out_msg_->is_bigendian = false;
//	point_cloud_out_msg_->is_dense = false;
//	point_cloud_out_msg_->data.resize(point_cloud_out_msg_->height * point_cloud_out_msg_->width * element_size);


	//prepare pcl point cloud
	pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_to_pcl_cloud(new pcl::PointCloud<pcl::PointXYZ>);

	//transform imported pointcloud to pcl::PointCloud<pcl::PointXYZ>
	pcl::fromROSMsg(*point_cloud_msg, *transformed_to_pcl_cloud);
	transformed_to_pcl_cloud->header.frame_id = "transformed_to_pcl_cloud";
	//====change point cloud here======================================

	//change color to red
	pcl::PointCloud<pcl::PointXYZRGB>::Ptr point_cloud_colored(new pcl::PointCloud<pcl::PointXYZRGB>);
	point_cloud_colored = changeColorOfPc(transformed_to_pcl_cloud);
	point_cloud_colored->header.frame_id = "colored_pc";

	//find plane
//	pcl::PointCloud<pcl::PointXYZ>::Ptr point_cloud_plane(new pcl::PointCloud<pcl::PointXYZ>);
//	point_cloud_plane = detectPlaneOfPc(transformed_to_pcl_cloud);
//	point_cloud_plane->header.frame_id = "plane_pc";

	//===changed point cloud===========================================
	//transform pcl::PointCloud<pcl::PointXYZ> to ros message
	pcl::toROSMsg(*transformed_to_pcl_cloud, *point_cloud_out_msg_);

	std::cout << "> Publish PC." << std::endl;

	point_cloud_out_msg_->header.frame_id = "point_cloud_out_msg";
	pub_.publish(point_cloud_out_msg_);


	std::cout << "< Ending PC callback." << std::endl;

}







pcl::PointCloud<pcl::PointXYZRGB>::Ptr PcImport::changeColorOfPc(pcl::PointCloud<pcl::PointXYZ>::Ptr input_cloud)
{
	std::cout << ">>> Starting PC color change." << std::endl;
	uint8_t r = 255, g = 155, b = 169;

	pcl::PointCloud<pcl::PointXYZRGB>::Ptr pointcloud_xyzrgb(new pcl::PointCloud<pcl::PointXYZRGB>);
	pcl::PointXYZRGB pclPoint;

	pcl::PointCloud<pcl::PointXYZ>::iterator it;
	for(it = input_cloud->points.begin();it < input_cloud->points.end();++it)
	{
		pclPoint.x = it->x;
		pclPoint.y = it->y;
		pclPoint.z = it->z;

		pclPoint.r = r;
		pclPoint.g = g;
		pclPoint.b = b;

		pointcloud_xyzrgb->points.push_back(pclPoint);
	}

	std::cout << "<<< Ending PC color change." << std::endl;
	return pointcloud_xyzrgb;
}


pcl::PointCloud<pcl::PointXYZ>::Ptr PcImport::detectPlaneOfPc(pcl::PointCloud<pcl::PointXYZ>::Ptr input_cloud)
{
	std::cout << ">>> Starting plane detection of PC." << std::endl;
	pcl::PointCloud<pcl::PointXYZ>::Ptr pc_planes(new pcl::PointCloud<pcl::PointXYZ>);

	pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients);
	pcl::PointIndices::Ptr inliers (new pcl::PointIndices);
	// Create the segmentation object
	pcl::SACSegmentation<pcl::PointXYZ> seg;
	// Optional
	seg.setOptimizeCoefficients (true);
	// Mandatory
	seg.setModelType (pcl::SACMODEL_PLANE);
	seg.setMethodType (pcl::SAC_RANSAC);
	seg.setDistanceThreshold (0.01);

	seg.setInputCloud (input_cloud);
	seg.segment (*inliers, *coefficients);

	pcl::PointXYZ pclPoint;
	for (size_t i = 0; i < inliers->indices.size (); ++i)
	{
		pclPoint.x = input_cloud->points[inliers->indices[i]].x;
		pclPoint.y = input_cloud->points[inliers->indices[i]].y;
		pclPoint.z = input_cloud->points[inliers->indices[i]].z;
		pc_planes->points.push_back(pclPoint);
	}

	std::cout << "<<< Ending plane detection of PC." << std::endl;
	return pc_planes;
}




//===main=================================================================================================================
int main(int argc, char **argv)
{
	ros::init(argc, argv, "my_pcl_image_listener");
	ros::NodeHandle nh;


	sensor_msgs::PointCloud2::Ptr point_cloud_out_msg(new sensor_msgs::PointCloud2);
	PcImport pcImport(nh, point_cloud_out_msg);
	return 0;
}

